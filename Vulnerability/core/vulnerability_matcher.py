import pandas as pd

def match_pcap_to_exploits(pcap_csv_path, exploit_csv_path, output_csv_path=None):
    """
    Matches extracted PCAP data to known vulnerabilities based on keywords in HTTP/DNS/Info fields.

    Parameters:
        pcap_csv_path (str): Path to PCAP-extracted CSV.
        exploit_csv_path (str): Path to merged ExploitDB + NVD CSV.
        output_csv_path (str, optional): Path to save the results.

    Returns:
        pd.DataFrame: Matched exploit rows.
    """
    # Load extracted PCAP data and fill empty values
    pcap_df = pd.read_csv(pcap_csv_path).dropna(how='all', axis=1).fillna("")
    
    # Load known exploits database
    exploit_df = pd.read_csv(exploit_csv_path).fillna("")

    # Normalize strings for case-insensitive matching
    exploit_df['description_x'] = exploit_df['description_x'].astype(str).str.lower()
    exploit_df['cve_id'] = exploit_df['cve_id'].astype(str).str.upper()

    # Columns in PCAP likely to contain indicators (hostnames, URLs, protocols, etc.)
    fields_to_match = ['http.host', 'http.user_agent', 'dns.qry.name', '_ws.col.Info']

    matches = []

    # Iterate over each row in the PCAP and check for matches in exploit descriptions
    for _, row in pcap_df.iterrows():
        # Combine searchable text from important fields
        search_terms = " ".join(str(row[field]).lower() for field in fields_to_match if field in row and row[field])

        # Use available MAC address from Ethernet or Wi-Fi layer
        src_mac = row.get("eth.src") or row.get("wlan.sa") or ""
        dst_mac = row.get("eth.dst") or row.get("wlan.da") or ""

        # Compare search terms to each known exploit
        for _, exp in exploit_df.iterrows():
            if any(term in search_terms for term in exp['description_x'].split()):
                matches.append({
                    "ip.src": row.get("ip.src", ""),
                    "mac.src": src_mac,
                    "ip.dst": row.get("ip.dst", ""),
                    "mac.dst": dst_mac,
                    "matched_info": search_terms,
                    "exploit_description": exp['description_x'],
                    "cve_id": exp['cve_id']
                })
                break  # Stop at first match to avoid duplicates

    # Format and optionally write to CSV
    matches_df = pd.DataFrame(matches)
    if output_csv_path:
        matches_df.to_csv(output_csv_path, index=False)

    return matches_df


def match_nmap_to_exploits(xml_csv_path, exploit_csv_path, output_csv_path=None):
    """
    Matches extracted Nmap XML service data to known vulnerabilities using service name/product/version/CPE.

    Parameters:
        xml_csv_path (str): Path to extracted Nmap CSV.
        exploit_csv_path (str): Path to merged ExploitDB + NVD CSV.
        output_csv_path (str, optional): Path to save the results.

    Returns:
        pd.DataFrame: Matched exploit rows.
    """
    # Load Nmap scan output
    nmap_df = pd.read_csv(xml_csv_path).fillna("")
    
    # Load known exploits database
    exploit_df = pd.read_csv(exploit_csv_path).fillna("")

    # Normalize fields
    exploit_df['description_x'] = exploit_df['description_x'].astype(str).str.lower()
    exploit_df['cve_id'] = exploit_df['cve_id'].astype(str).str.upper()

    matches = []

    # Iterate over each service discovered by Nmap
    for _, row in nmap_df.iterrows():
        # Combine service identifiers into a search string
        search_terms = " ".join(str(row.get(k, "")).lower() for k in ['service_name', 'product', 'version', 'cpe'])

        # Match against each known exploit description
        for _, exp in exploit_df.iterrows():
            if any(term in search_terms for term in exp['description_x'].split()):
                matches.append({
                    "ip_address": row.get("ip_address", ""),
                    "service_name": row.get("service_name", ""),
                    "product": row.get("product", ""),
                    "version": row.get("version", ""),
                    "cpe": row.get("cpe", ""),
                    "matched_info": search_terms,
                    "exploit_description": exp['description_x'],
                    "cve_id": exp['cve_id']
                })
                break  # First match wins

    # Format and optionally write to CSV
    matches_df = pd.DataFrame(matches)
    if output_csv_path:
        matches_df.to_csv(output_csv_path, index=False)

    return matches_df