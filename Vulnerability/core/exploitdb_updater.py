#!/usr/bin/env python3
"""
Safe ExploitDB Updater for Vulnerability Assessment Pipeline
Downloads only the vulnerability database CSV (no exploit code files) to avoid antivirus flags.
Focus on vulnerability matching data only.
"""

import os
import requests
import pandas as pd
from datetime import datetime
import re
from typing import Optional, Dict


class SafeExploitDBUpdater:
    def __init__(self):
        # Only download the CSV metadata - no exploit files that trigger antivirus
        self.csv_url = "https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv"
        self.cve_mapping_url = "https://raw.githubusercontent.com/CVEProject/cvelistV5/main/cves/2024/0xxx/CVE-2024-0001.json"  # Example for structure
        self.exploitdb_dir = os.path.join("exploit_db", "database_only")
        
        # Focus only on vulnerability types that match to CVEs
        self.allowed_types = [
            'remote', 'local', 'webapps', 'dos', 'papers',  # Safe research categories
            # Exclude: 'shellcode', 'exploits' (may trigger antivirus)
        ]
        
    def download_safe_vulnerability_db(self):
        """Download only the vulnerability database CSV - no exploit files to avoid antivirus flags"""
        
        print("[*] Downloading safe vulnerability database (CSV only)...")
        print("    NOTE: Only downloading metadata, no exploit files to avoid antivirus detection")
        
        try:
            response = requests.get(self.csv_url, timeout=60)
            response.raise_for_status()
            
            # Save to database directory
            csv_file = os.path.join(self.exploitdb_dir, "vulnerability_database.csv")
            
            with open(csv_file, 'wb') as f:
                f.write(response.content)
                
            print(f"[✓] Safe vulnerability database saved to: {csv_file}")
            
            # Load and filter the data for safe types only
            df = pd.read_csv(csv_file)
            
            # Filter to only include vulnerability research types (not actual exploit code)
            if 'type' in df.columns:
                df = df[df['type'].isin(self.allowed_types)].copy()
                print(f"[✓] Filtered to safe vulnerability types only")
            
            print(f"[✓] Safe Vulnerability Database Summary:")
            print(f"    - Total vulnerability entries: {len(df)}")
            
            if 'date' in df.columns:
                # Convert date column and get recent vulnerabilities
                df['date'] = pd.to_datetime(df['date'], errors='coerce')
                recent_vulns = df[df['date'] > '2024-01-01']
                print(f"    - 2024+ vulnerabilities: {len(recent_vulns)}")
            
            if 'type' in df.columns:
                vuln_types = df['type'].value_counts()
                print(f"    - Vulnerability types included:")
                for vuln_type, count in vuln_types.items():
                    print(f"      * {vuln_type}: {count}")
            
            if 'platform' in df.columns:
                platforms = df['platform'].value_counts().head(10)
                print(f"    - Top platforms:")
                for platform, count in platforms.items():
                    print(f"      * {platform}: {count}")
                    
            return df
            
        except requests.exceptions.RequestException as e:
            print(f"[!] Error downloading ExploitDB CSV: {e}")
            return None
    
    def create_safe_vulnerability_index(self, df: pd.DataFrame) -> Optional[pd.DataFrame]:
        """Create safe vulnerability index focused only on CVE matching data"""
        
        if df is None:
            return None
            
        print("[*] Creating safe vulnerability index...")
        
        # Normalize column names
        df.columns = [col.strip().lower() for col in df.columns]
        
        # Extract CVE patterns from multiple fields - focus on vulnerability IDs only
        cve_pattern = re.compile(r'CVE-\d{4}-\d{4,7}', re.IGNORECASE)
        
        def extract_vulnerability_identifiers(row):
            """Extract only vulnerability identifiers, not exploit code"""
            identifiers = set()
            
            # Check safe fields for vulnerability IDs
            safe_fields = ['description', 'tags', 'author']  # Avoid 'codes' which may contain exploit code
            
            for field in safe_fields:
                if field in row and isinstance(row[field], str):
                    # Extract CVEs
                    found_cves = cve_pattern.findall(row[field])
                    identifiers.update([cve.upper() for cve in found_cves])
            
            return ';'.join(sorted(identifiers)) if identifiers else ''
        
        # Extract vulnerability identifiers only
        df['vulnerability_ids'] = df.apply(extract_vulnerability_identifiers, axis=1)
        
        # Filter to only entries with CVE references (actual vulnerabilities)
        df_with_cves = df[df['vulnerability_ids'] != ''].copy()
        
        print(f"[✓] Vulnerability entries with CVE references: {len(df_with_cves)}")
        
        # Create clean vulnerability index with safe fields only
        safe_columns = ['id', 'description', 'date', 'author', 'type', 'platform', 'vulnerability_ids']
        available_columns = [col for col in safe_columns if col in df_with_cves.columns]
        
        clean_df = df_with_cves[available_columns].copy()
        
        # Add vulnerability year analysis
        def extract_vulnerability_years(vuln_ids):
            if not vuln_ids:
                return ''
            years = set()
            for cve in vuln_ids.split(';'):
                if cve.startswith('CVE-'):
                    year = cve.split('-')[1]
                    years.add(year)
            return ';'.join(sorted(years))
        
        clean_df['vulnerability_years'] = clean_df['vulnerability_ids'].apply(extract_vulnerability_years)
        
        # Save safe vulnerability index
        safe_index_file = os.path.join(self.exploitdb_dir, "safe_vulnerability_index.csv")
        clean_df.to_csv(safe_index_file, index=False)
        print(f"[✓] Safe vulnerability index saved to: {safe_index_file}")
        print(f"    Contains ONLY vulnerability metadata - no exploit code")
        
        return clean_df
    
    def update_safe_vulnerability_db(self) -> Optional[pd.DataFrame]:
        """Main method to safely update vulnerability database (no exploit files)"""
        
        print("[*] Starting Safe Vulnerability Database Update")
        print("=" * 50)
        print("    Downloading ONLY vulnerability metadata - no exploit code")
        print("    This avoids Windows Defender antivirus flags")
        print("=" * 50)
        
        # Create directory if needed
        os.makedirs(self.exploitdb_dir, exist_ok=True)
        
        # Download and process safe vulnerability data
        df = self.download_safe_vulnerability_db()
        
        if df is not None:
            # Create safe vulnerability index
            safe_df = self.create_safe_vulnerability_index(df)
            
            print("\n[✓] Safe vulnerability database update completed!")
            print("    ✓ No exploit files downloaded")
            print("    ✓ Only CVE vulnerability references")
            print("    ✓ Safe for Windows Defender")
            return safe_df
        else:
            print("\n[!] Vulnerability database update failed!")
            return None
    
    def get_vulnerability_stats(self) -> Dict:
        """Get statistics about the current vulnerability database"""
        
        safe_index_file = os.path.join(self.exploitdb_dir, "safe_vulnerability_index.csv")
        
        if not os.path.exists(safe_index_file):
            return {"error": "No vulnerability database found. Run update_safe_vulnerability_db() first."}
        
        try:
            df = pd.read_csv(safe_index_file)
            
            stats = {
                "total_vulnerabilities": len(df),
                "vulnerabilities_with_cves": len(df[df['vulnerability_ids'] != '']),
                "recent_vulnerabilities": 0,
                "vulnerability_types": {},
                "top_platforms": {},
                "database_file": safe_index_file
            }
            
            # Analyze recent vulnerabilities
            if 'date' in df.columns:
                df['date'] = pd.to_datetime(df['date'], errors='coerce')
                recent = df[df['date'] > '2024-01-01']
                stats["recent_vulnerabilities"] = len(recent)
            
            # Analyze types
            if 'type' in df.columns:
                stats["vulnerability_types"] = df['type'].value_counts().to_dict()
            
            # Analyze platforms  
            if 'platform' in df.columns:
                stats["top_platforms"] = df['platform'].value_counts().head(10).to_dict()
            
            return stats
            
        except Exception as e:
            return {"error": f"Failed to analyze vulnerability database: {str(e)}"}


def main():
    """Main function for safe vulnerability database management"""
    
    print("Safe Vulnerability Database Manager")
    print("=" * 40)
    print("Downloads ONLY vulnerability metadata - no exploit code")
    print("Prevents Windows Defender antivirus flags")
    print()
    
    updater = SafeExploitDBUpdater()
    
    # Update the database
    result = updater.update_safe_vulnerability_db()
    
    if result is not None:
        # Show statistics
        stats = updater.get_vulnerability_stats()
        
        if "error" not in stats:
            print(f"\n[📊] Vulnerability Database Statistics:")
            print(f"    Total entries: {stats['total_vulnerabilities']}")
            print(f"    With CVE references: {stats['vulnerabilities_with_cves']}")
            print(f"    Recent (2024+): {stats['recent_vulnerabilities']}")
            
            print(f"\n[🔍] Top vulnerability types:")
            for vuln_type, count in list(stats['vulnerability_types'].items())[:5]:
                print(f"    • {vuln_type}: {count}")
        
        print(f"\n[✅] Safe vulnerability database ready for matching!")
    else:
        print(f"\n[❌] Failed to update vulnerability database")


if __name__ == "__main__":
    main()