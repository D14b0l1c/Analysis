import subprocess
import pandas as pd
import re
from typing import Optional, List, Dict

def export_pcap_to_csv(pcap_path: str, output_csv: str, display: bool = True) -> None:
    """
    Uses tshark to extract a rich set of fields from a PCAP file and writes them to a CSV file.
    
    Parameters:
    - pcap_path (str): Full path to the input PCAP file.
    - output_csv (str): Destination path for the extracted CSV output.
    - display (bool): If True, prints progress and errors to the console.
    
    Tshark must be installed and available in the system PATH.
    The fields include Ethernet, IP, TCP/UDP, Wi-Fi, DNS, HTTP, TLS, and GPS metadata.
    """
    # Construct the tshark command with required fields
    tshark_command = [
        "tshark", "-r", pcap_path, "-T", "fields",

        # Frame metadata
        "-e", "frame.time_epoch", "-e", "frame.number", "-e", "frame.len", "-e", "frame.cap_len",
        "-e", "frame.encap_type", "-e", "frame.time_delta_displayed",

        # Ethernet / Wi-Fi addresses and properties
        "-e", "eth.src", "-e", "eth.dst",
        "-e", "wlan_radio.signal_db", "-e", "wlan_radio.channel",
        "-e", "wlan.ssid", "-e", "wlan.bssid", "-e", "wlan.sa", "-e", "wlan.ta", "-e", "wlan.ra", "-e", "wlan.da",

        # IP layer
        "-e", "ip.proto", "-e", "ip.src", "-e", "ip.dst", "-e", "ip.ttl",
        "-e", "ipv6.src", "-e", "ipv6.dst",

        # TCP layer
        "-e", "tcp.srcport", "-e", "tcp.dstport", "-e", "tcp.seq_raw", "-e", "tcp.len", "-e", "tcp.stream",
        "-e", "tcp.hdr_len", "-e", "tcp.flags", "-e", "tcp.window_size",
        "-e", "tcp.options.unknown.payload", "-e", "tcp.analysis",

        # UDP layer
        "-e", "udp.srcport", "-e", "udp.dstport",

        # DNS layer - For vulnerability detection
        "-e", "dns.qry.name", "-e", "dns.resp.name", "-e", "dns.a", "-e", "dns.aaaa", 
        "-e", "dns.cname", "-e", "dns.flags.rcode", "-e", "dns.qry.type",

        # HTTP layer - Comprehensive web vulnerability detection
        "-e", "http.request.method", "-e", "http.request.uri", "-e", "http.request.full_uri",
        "-e", "http.host", "-e", "http.user_agent", "-e", "http.server", "-e", "http.response.code",
        "-e", "http.authorization", "-e", "http.cookie", "-e", "http.referer",
        "-e", "http.content_type", "-e", "http.x_forwarded_for", "-e", "http.file_data",

        # TLS/SSL layer - Security analysis
        "-e", "tls.handshake.ciphersuite", "-e", "tls.handshake.version", "-e", "tls.handshake.type",
        "-e", "tls.handshake.extensions.server_name", "-e", "ssl.record.version", "-e", "tls.alert.description",

        # Vulnerability-prone protocols
        "-e", "ftp.request.command", "-e", "ftp.response.code", "-e", "telnet.data",
        "-e", "smtp.command", "-e", "pop.request.command", "-e", "imap.request.command",
        "-e", "snmp.community", "-e", "snmp.version", "-e", "snmp.pdu_type",

        # SMB/CIFS - Common attack vector
        "-e", "smb.cmd", "-e", "smb2.cmd", "-e", "smb.file", "-e", "smb.path",
        "-e", "nbns.name", "-e", "browser.server",

        # Network services
        "-e", "ssh.protocol", "-e", "ssh.message_code", "-e", "rpc.program", "-e", "ntp.stratum",
        "-e", "dhcp.option.hostname", "-e", "dhcp.option.vendor_class_id",

        # ICMP - Network reconnaissance
        "-e", "icmp.type", "-e", "icmp.code", "-e", "icmpv6.type",

        # Display columns (summary protocol info)
        "-e", "_ws.col.Protocol", "-e", "_ws.col.Info", "-e", "_ws.col.Source", "-e", "_ws.col.Destination",

        # Output formatting
        "-E", "header=y", "-E", "separator=,", "-E", "quote=d"
    ]

    # Run tshark and write its output to CSV
    try:
        with open(output_csv, "w", encoding="utf-8") as f:
            subprocess.run(tshark_command, check=True, stdout=f, text=True)
        if display:
            print(f"Export complete: {output_csv}")
    except subprocess.CalledProcessError as e:
        if display:
            print(f"Tshark error: {e}")
    except Exception as e:
        if display:
            print(f"Unexpected error: {e}")

def export_pcap_with_vuln_filters(pcap_path: str, output_csv: str, filter_type: str = "all", display: bool = True) -> None:
    """
    PCAP extraction with vulnerability-specific filters.
    
    Parameters:
    - pcap_path (str): Full path to the input PCAP file.
    - output_csv (str): Destination path for the extracted CSV output.
    - filter_type (str): Type of vulnerability filter ('router', 'web', 'weak_auth', 'all').
    - display (bool): If True, prints progress and errors to the console.
    """
    
    # Define vulnerability-specific Wireshark display filters
    vuln_filters = {
        'router': '(http.host contains "admin" or http.request.uri contains "cgi-bin" or ' +
                 'http.user_agent contains "router" or snmp or telnet or ' +
                 'http.request.uri contains "setup" or http.request.uri contains "config")',
        
        'web': '(http.request.method == "POST" or http.request.uri contains "login" or ' +
              'http.request.uri contains "admin" or http.authorization or ' +
              'http.request.uri contains "sql" or http.request.uri contains "xss")',
        
        'weak_auth': '(http.authorization contains "Basic" or ftp.request.command == "USER" or ' +
                    'pop.request.command == "USER" or telnet or snmp.version == 1)',
        
        'iot': '(mdns or upnp or coap or mqtt or http.host matches "192\\\\.168\\\\." or ' +
              'dhcp.option.vendor_class_id contains "iot")',
        
        'suspicious': '(dns.qry.name contains "malware" or dns.qry.name contains "bot" or ' +
                     'dns.qry.name contains "c2" or http.user_agent contains "bot" or ' +
                     'icmp.type == 8 and frame.len > 1000)',
        
        'all': ''  # No filter - extract everything
    }
    
    # Get the appropriate filter
    display_filter = vuln_filters.get(filter_type, vuln_filters['all'])
    
    # Build tshark command with vulnerability-focused fields
    tshark_command = [
        "tshark", "-r", pcap_path, "-T", "fields"
    ]
    
    # Add display filter if specified
    if display_filter:
        tshark_command.extend(["-Y", display_filter])
    
    # Field set for vulnerability assessment
    fields = [
        # Frame metadata
        "frame.time_epoch", "frame.number", "frame.len", "frame.protocols",
        
        # Network layer
        "eth.src", "eth.dst", "ip.src", "ip.dst", "ip.proto", "ip.ttl",
        "ipv6.src", "ipv6.dst", "tcp.srcport", "tcp.dstport", "tcp.flags",
        "udp.srcport", "udp.dstport",
        
        # WiFi layer
        "wlan.ssid", "wlan.bssid", "wlan.sa", "wlan.da", "wlan_radio.channel",
        
        # Application protocols - vulnerability focus
        "dns.qry.name", "dns.resp.name", "dns.a",
        "http.request.method", "http.request.uri", "http.host", "http.user_agent",
        "http.server", "http.response.code", "http.authorization", "http.cookie",
        "http.content_type", "http.file_data",
        
        # Security-relevant protocols
        "tls.handshake.extensions.server_name", "ssl.record.version",
        "ftp.request.command", "telnet.data", "smtp.command",
        "snmp.community", "snmp.version", "ssh.protocol",
        "smb.cmd", "smb2.cmd", "smb.path",
        
        # Network services and reconnaissance
        "dhcp.option.hostname", "nbns.name", "icmp.type",
        "rpc.program", "ntp.stratum",
        
        # Summary columns
        "_ws.col.Protocol", "_ws.col.Info", "_ws.col.Source", "_ws.col.Destination"
    ]
    
    # Add field extraction parameters
    for field in fields:
        tshark_command.extend(["-e", field])
    
    # Output formatting
    tshark_command.extend(["-E", "header=y", "-E", "separator=,", "-E", "quote=d"])
    
    # Execute tshark
    try:
        with open(output_csv, "w", encoding="utf-8") as f:
            subprocess.run(tshark_command, check=True, stdout=f, text=True)
        if display:
            print(f"Vulnerability-focused extraction complete: {output_csv}")
            print(f"Filter applied: {filter_type}")
    except subprocess.CalledProcessError as e:
        if display:
            print(f"Tshark error: {e}")
    except Exception as e:
        if display:
            print(f"Unexpected error: {e}")


def analyze_pcap_for_vulnerabilities(csv_path: str) -> Dict:
    """
    Analyze extracted PCAP data for vulnerability indicators.
    
    Parameters:
    - csv_path (str): Path to the extracted PCAP CSV file.
    
    Returns:
    - Dict: Analysis results with vulnerability indicators.
    """
    try:
        df = pd.read_csv(csv_path)
        
        analysis = {
            'total_packets': len(df),
            'vulnerability_indicators': {},
            'network_services': {},
            'suspicious_activity': {},
            'device_fingerprints': {}
        }
        
        # Analyze HTTP traffic for vulnerabilities
        if 'http.request.uri' in df.columns:
            suspicious_uris = df[df['http.request.uri'].str.contains(
                r'(admin|login|setup|config|cgi-bin|\.php\?|sql|xss)', case=False, na=False
            )]
            analysis['vulnerability_indicators']['suspicious_web_paths'] = len(suspicious_uris)
        
        # Check for weak authentication
        if 'http.authorization' in df.columns:
            basic_auth = df[df['http.authorization'].str.contains('Basic', na=False)]
            analysis['vulnerability_indicators']['basic_auth_usage'] = len(basic_auth)
        
        # Analyze unencrypted protocols
        protocols = df['_ws.col.Protocol'].value_counts().to_dict() if '_ws.col.Protocol' in df.columns else {}
        weak_protocols = ['FTP', 'TELNET', 'HTTP', 'SNMP']
        analysis['vulnerability_indicators']['unencrypted_protocols'] = {
            proto: protocols.get(proto, 0) for proto in weak_protocols if proto in protocols
        }
        
        # Network service discovery
        if 'tcp.dstport' in df.columns:
            common_ports = df['tcp.dstport'].value_counts().head(10).to_dict()
            analysis['network_services']['tcp_ports'] = common_ports
        
        # DNS analysis for suspicious domains
        if 'dns.qry.name' in df.columns:
            dns_queries = df['dns.qry.name'].dropna()
            suspicious_dns = dns_queries[dns_queries.str.contains(
                r'(malware|bot|c2|trojan)', case=False, na=False
            )]
            analysis['suspicious_activity']['suspicious_dns_queries'] = len(suspicious_dns)
        
        # Device fingerprinting
        if 'http.user_agent' in df.columns:
            user_agents = df['http.user_agent'].value_counts().head(5).to_dict()
            analysis['device_fingerprints']['user_agents'] = user_agents
        
        return analysis
        
    except Exception as e:
        return {'error': f"Analysis failed: {str(e)}"}


def generate_vuln_focused_report(pcap_path: str, output_dir: str) -> Dict[str, str]:
    """
    Generate vulnerability-focused PCAP analysis reports.
    
    Parameters:
    - pcap_path (str): Path to input PCAP file.
    - output_dir (str): Directory to save analysis files.
    
    Returns:
    - Dict: Mapping of analysis types to output file paths.
    """
    import os
    
    os.makedirs(output_dir, exist_ok=True)
    
    reports = {}
    
    # Extract different vulnerability categories
    categories = ['router', 'web', 'weak_auth', 'iot', 'suspicious', 'all']
    
    for category in categories:
        output_csv = os.path.join(output_dir, f"vuln_{category}_extract.csv")
        export_pcap_with_vuln_filters(pcap_path, output_csv, category)
        
        # Analyze the extracted data
        analysis = analyze_pcap_for_vulnerabilities(output_csv)
        
        # Save analysis report
        analysis_json = os.path.join(output_dir, f"vuln_{category}_analysis.json")
        with open(analysis_json, 'w') as f:
            import json
            json.dump(analysis, f, indent=2)
        
        reports[category] = {
            'csv': output_csv,
            'analysis': analysis_json,
            'packet_count': analysis.get('total_packets', 0)
        }
    
    return reports


# If this script is executed directly, run an example extraction
if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1:
        pcap_file = sys.argv[1]
        output_csv = "pcap_extraction.csv"
        
        print("PCAP Vulnerability Extractor")
        print("=" * 40)
        
        # Run extraction
        export_pcap_with_vuln_filters(pcap_file, output_csv, "all")
        
        # Analyze results
        analysis = analyze_pcap_for_vulnerabilities(output_csv)
        print(f"\nAnalysis Results:")
        print(f"Total packets: {analysis.get('total_packets', 0)}")
        print(f"Vulnerability indicators: {len(analysis.get('vulnerability_indicators', {}))}")
        
        # Generate comprehensive report
        reports = generate_vuln_focused_report(pcap_file, "vulnerability_analysis")
        print(f"\nGenerated {len(reports)} specialized reports in 'vulnerability_analysis/' directory")
        
    else:
        print("Usage: python pcap_extractor.py <pcap_file>")
        print("Example: python pcap_extractor.py network_traffic.pcap")