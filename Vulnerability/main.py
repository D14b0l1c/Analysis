import os
import sys

# Import extractors and matchers for both PCAP and Nmap XML
from core.pcap_extractor import export_pcap_to_csv, export_pcap_with_vuln_filters, analyze_pcap_for_vulnerabilities
from core.xml_extractor import export_nmap_xml_to_csv, export_nmap_with_vuln_analysis, extract_vulnerability_indicators
from core.vulnerability_matcher import match_pcap_to_exploits, match_nmap_to_exploits

def run_pcap_pipeline(pcap_path: str):
    """
    Executes the extraction and matching pipeline for PCAP input.

    Parameters:
        pcap_path (str): Path to the input PCAP file.
    """
    # Define file paths for output
    extracted_csv = "data/output/pcap_extracted_output.csv"
    matches_csv = "data/output/pcap_matches.csv"
    exploit_csv_path = os.path.join("exploit_db", "index", "exploitdb_with_nvd.csv")

    # Step 1: Extract features from the PCAP using extractor
    print(f"[1/4] Extracting vulnerability-focused fields from PCAP: {pcap_path}")
    export_pcap_with_vuln_filters(pcap_path, extracted_csv, "all")

    # Step 2: Analyze PCAP for vulnerability indicators
    print(f"[2/4] Analyzing PCAP for vulnerability indicators...")
    vuln_analysis = analyze_pcap_for_vulnerabilities(extracted_csv)
    print(f"     Found {vuln_analysis.get('total_packets', 0)} packets to analyze")
    
    # Step 3: Match extracted data to known exploits
    print(f"[3/4] Matching traffic to known exploits from: {exploit_csv_path}")
    df = match_pcap_to_exploits(extracted_csv, exploit_csv_path, matches_csv)

    # Step 4: Output results
    print(f"[4/4] PCAP analysis complete. {len(df)} potential matches found.")
    print(f"     Vulnerability indicators: {len(vuln_analysis.get('vulnerability_indicators', {}))}")
    print(f"Results written to: {matches_csv}")


def run_nmap_pipeline(xml_path: str):
    """
    Executes the extraction and matching pipeline for Nmap XML input.

    Parameters:
        xml_path (str): Path to the input Nmap XML file.
    """
    # Define file paths for output
    extracted_csv = "data/output/nmap_extracted_output.csv"
    matches_csv = "data/output/nmap_matches.csv"
    exploit_csv_path = os.path.join("exploit_db", "index", "exploitdb_with_nvd.csv")

    # Step 1: Extract Nmap scan fields with vulnerability analysis
    print(f"[1/4] Extracting fields from Nmap XML: {xml_path}")
    analysis_summary = export_nmap_with_vuln_analysis(xml_path, extracted_csv, include_scripts=True)

    # Step 2: Extract vulnerability indicators
    print(f"[2/4] Extracting vulnerability indicators from scan results...")
    vuln_indicators = extract_vulnerability_indicators(xml_path)
    print(f"     Found {len(vuln_indicators.get('cve_references', []))} CVE references")
    print(f"     Found {len(vuln_indicators.get('vulnerable_services', []))} vulnerable services")
    
    # Step 3: Match to exploits using service name, product, version, or CPE
    print(f"[3/4] Matching discovered services to known exploits...")
    df = match_nmap_to_exploits(extracted_csv, exploit_csv_path, matches_csv)

    # Step 4: Output results
    print(f"[4/4] Nmap analysis complete. {len(df)} potential matches found.")
    if not analysis_summary.get('error'):
        host_summary = analysis_summary['host_summary']
        print(f"     Vulnerable services: {host_summary['vulnerable_services']}")
        print(f"     Critical vulnerabilities: {host_summary['critical_vulns']}")
    print(f"Results written to: {matches_csv}")


def run_pipeline(input_file: str):
    """
    Routes the input file to the appropriate analysis pipeline.

    Parameters:
        input_file (str): Full path to the input PCAP or XML file.
    """
    # Determine file type based on its extension
    ext = os.path.splitext(input_file)[1].lower()

    if ext in [".pcap", ".pcapng", ".pcapppi"]:
        run_pcap_pipeline(input_file)
    elif ext == ".xml":
        run_nmap_pipeline(input_file)
    else:
        # Handle unsupported file types
        print(f"Unsupported file extension: {ext}")
        print("Supported types: .pcap, .pcapng, .pcapppi, .xml")


if __name__ == "__main__":
    # Default path for testing if user presses Enter
    default_path = "data/input/vulnerable_traffic.pcap"
    
    # Prompt user for input file, fallback to default
    user_input = input(f"Enter path to input file [{default_path}]: ").strip()
    input_path = user_input if user_input else default_path

    # Ensure the file exists before proceeding
    if not os.path.isfile(input_path):
        print(f"File not found: {input_path}")
        sys.exit(1)

    # Run the correct pipeline for this input
    run_pipeline(input_path)